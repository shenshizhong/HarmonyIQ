

UBoot 加载驱动 （在加载Linux内核之前进行加载的）
```
一、先设置宏定义：
u-boot/configs/rk3568_defconfig
CONFIG_LED=y
CONFIG_LED_BLINK=y
CONFIG_LED_GPIO=y


二、
准备添加设备树的一些内容：
u-boot/arch/arm/dts/rk3568-evb.dts

通过这个命令，去查找引脚的位置：
/u-boot$ grep -rl "RK_PB7"

最终发现是在这个头文件中定义的：u-boot/include/dt-bindings/pinctrl/rockchip.h


设备树：/u-boot/arch/arm/dts/rk3568-evb.dts

根目录下面的 adc-keys 后面添加：
	leds{
		compatible = "gpio-leds";
		u-boot,dm-pre-reloc;   //第一二阶段生效需要加的内容
		status = "okay";
		green_led{
			gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;  //Led 的GPIO 控制器 gpio0， 引脚为RK_PB7, 有效电平为高电平
			label = "lable_green"; //添加标签
			default-state = "on"; 
		    u-boot,dm-pre-reloc; //第一二阶段生效需要加的内容

		};
	};


三、开始注册以及添加驱动
/u-boot/drivers/led/led-uclass.c
/u-boot/drivers/led/led_gpio.c

UCLASS_LED 定义在：
/u-boot/include/dm/uclass-id.h


/uboot/u-boot/drivers/led/led_gpio.c 最后添加：
U_BOOT_DRIVER(led_gpio) = {
	.name	= "gpio_led",
	.id	= UCLASS_LED,
	.of_match = led_gpio_ids,
	.ops	= &gpio_led_ops,
	.priv_auto_alloc_size = sizeof(struct led_gpio_priv),
	.bind	= led_gpio_bind,
	.probe	= led_gpio_probe,
	.remove	= led_gpio_remove,
};


四、加载驱动 并开启led
/uboot/u-boot/common/board_r.c
1、
在头部添加 #include <led.h> 

2、
static int initr_dm(void){} 后面添加方法：
/*ssz新增*/
static int initr_led(void)
{
	struct udevice *dev;
	u32 ret = 0;
	ret = led_get_by_label("lable_green", &dev);
	if(ret){
		printf("led_gpio fail, ret=%d\n", ret);
	}
	printf("ssz initr_led name=%s ... \n", dev->name);
	led_set_state(dev, LEDST_ON);
	return 0;
}

3、这里是调用，也就是加载驱动最开始的地方：
在 initr_dm 后面 initr_led 添加如下：
#ifdef CONFIG_DM
	initr_dm,
#endif

initr_led,

```