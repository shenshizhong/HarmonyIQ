
通过pwm控制led灯
```

一、将pwm0 设置一个标签，为后面查找设备做准备：

oh40/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568-toybrick.dtsi
&pwm0 {
	status = "okay";
	rockchip, maniu; //这里是修改的地方
};

./build.sh --product-name rk3568 --ccache --build-target kernel


最终生成两个需要烧录的像 boot_linux.img   resource.img(包含设备树dtb) 

这个地方是理解代码用的几个文件：
oh40/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi
oh40/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi
oh40/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rockchip-pinconf.dtsi


二、添加查找设备的函数

1、
/home/ssz/sszhome/workplace/uboot/u-boot/drivers/pwm/pwm-uclass.c

//查找设备的函数：
int pwm_get_dev(struct udevice **devp)
{
	struct udevice *dev;
	struct uclass *uc;
	int ret;
	printf("ssz pwm_get_dev...enter\n");

	ret = uclass_get(UCLASS_PWM, &uc);
	if(ret)
		return ret;
	uclass_foreach_dev(dev, uc){
		printf("ppp ssz start to get pwm dev name = %s \n", dev->name);
		if(dev_read_bool(dev, "rockchip,maniu")){
			printf("ppp ssz got pwm dev name = %s\n", dev->name);
			return uclass_get_device_tail(dev, 0, devp);
		}else{
			printf("ppp ssz dev name = %s has no property\n", dev->name);
		}
	}
	printf("ssz pwm_get_devs...exit\n");
	return -ENODEV;	
}

2、
u-boot/include/pwm.h 增加函数声明：
/*ssz新增*/
int pwm_get_dev(struct udevice **devp);


三、调用
1、
在 /u-boot/common/board_r.c 中
添加头文件：#include <pwm.h>

2、
增加 maniu_pwm_init，还有静态的maniu_pwm_init 方法，如下：

#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV)
	board_init,	/* Setup chipselects */
	maniu_pwm_init,
#endif

#endif
	/* main_loop() can return to retry autoboot, if so just run it again */
	for (;;)
		main_loop();
	return 0;
}
/*ssz新增*/
static int maniu_pwm_init(void){
	struct udevice *dev;
	u32 ret = 0;

	prinitf("ssz maniu_pwm_init ...\n");

	ret = pwm_get_dev(&dev);
	if (ret)
	{
		prinitf("pwm_get_dev, ret=%d\n", ret);
		return 0;
	}
	pwm_set_invert(dev, 0, true);
	pwm_set_config(dev, 0, 1000000000, 500000000);
	pwm_set_enable(dev, 0, true);
	
	return 0;
}



```