
用户态程序与内核态驱动的交互       CopyFromUser
```
一、
LiteOs 主要的模块：
1、manager
2、platform
3、posix

platform:
1、BUILD.gn        drivers/hdf_core/adapter/uhdf/platform/BUILD.gn 
2、BUILD.gn 会编译一个hdf_platform 动态库，这个会和标准内核一起共用

manager：
1、BUILD.gn        drivers/hdf_core/adapter/uhdf/manager/BUILD.gn
2、BUILD.gn 会编译一个hdf_core 动态库

二、
Linux 内核空间代码：

hdf_core 里面的 bundle.json ：
1、drivers/hdf_core/bundle.json
2、定义组件component 名为 hdf_core
3、subsystem 为 hdf
4、发现 inner_kits 主要是给hdf2 用的
5、sub_component: udf_entry 作为入口

udf_entry：
1、是在这个 hdf_core/adapter/BUILD.gn 里面定义的
2、主要关注libhdf_ipc_adapter 和 libhdf_utils

libhdf_utils：
1、所在位置 drivers/hdf_core/adapter/uhdf2/utils/BUILD.gn
2、在BUILD 中被编译成动态库
```

序列化数据的交互
```
hdf_sbuf.c
hdf_sbuf_impl_raw.c

HdfSbufObtain:
1、会去调用 HdfSbufTypedObtainCapacity

HdfSbufTypedObtainCapacity：
1、最终返回的 HdfSBufRaw sbuf

HdfSBufRaw：
HdfSBufImpl infImpl
uint8_t *data

实现细节
SbufRawImplWrite：
1、最终执行 memcpy_s 进行拷贝

HdfIoService:
1、HdfIoServiceBind

```

消息机制的实现
```
syscall 被编译到用户空间
vnode   被编译到内核空间


一、用户态去绑定
HdfIoServiceBind：
1、内部是通过 HdfIoServiceAdapterObtain(serviceName) 绑定

HdfIoServiceAdapterObtain: 获取 iosService
1、先获取驱动服务地址 devPath
2、通过 sprintf_s 进行拼接   类似/dev/hdf/led_service
3、调用 realpath 检查有没有启动
4、通过 open 打开节点  真实的实现是 HdfVNodeAdapterOpen
5、然后将ioService 指向 &adapter->super 
6、再将 ioService 的 dispatcher 指向 &dispatch  （dispatch 实际就是 HdfSyscallAdapterDispatch）
7、最后 返回ioService


二、用户态的Dispatch
HdfSyscallAdapterDispatch:
1、获取 HdfSyscallAdapter ioService
2、将传入的数据进行存储
3、调用 ioctl，对设备特定的操作 实际是 HdfVNodeAdapterIoctl
 

三、内核态的操作：

HdfVNodeAdapterOpen： 
1、通过 OsalGetCdevPriv 获取 HdfVNodeAdapter *adapter
2、通过 HdfNewVNodeAdapterClient 创建 client 对象
3、通过 OsalSetFilePriv 把 client 绑定到 filep 的私有数据段中
4、通过 client.ioServiceClient.device->service  调用open 打开设备驱动服务

HdfVNodeAdapterIoctl： 通过它去调用驱动函数 
1、通过 OsalGetFilePriv 获取 HdfVNodeAdapterClient *client
2、判断传进来的 cmd 进行不同的操作
3、如果 cmd 是 HDF_WRITE_READ，执行 HdfVNodeAdapterServCall


HdfVNodeAdapterServCall：
1、将传入的参数 arg 强转成 HdfWriteReadBuf *bwrUser
2、通过 CopyFromUser 将用户态数据 拷贝 到内核态   （很重要，这就是用户态到内核态的转变）
3、通过 HdfSbufCopyFromUser 将数据还原
4、在内核空间 通过 HdfSbufObtainDefaultSize 申请一块内存存放reply
5、将要返回给用户态的数据写入 reply
6、接着调用 CopyToUser 将reply 的数据返回给用户态
7、通过 client->adapter->ioService.dispatcher 调用 Dispatch 实际是 DeviceNodeExtDispatch
8、最后释放 data reply

DeviceNodeExtDispatch： 这个是前面 DeviceNodeExtPublishService 里面会进行注册的
1、传入的第一个参数 client->adapter->ioService.target
2、紧接着 CONTAINER_OF 根据 deviceObject 的地址和 HdfDeviceNode 的偏移量，
   反向计算出 HdfDeviceNode 的起始地址，并记录到 devNode 中
3、最终通过deviceMethod 调用 Dispatch  （这样用户态方法 就到内核态了  也就是内核态 回调了 用户态方法）

```
用户态和内核态通信
```

CopyFromUser            用户态数据 传送 到内核态
CopyToUser              内核态 返回到 用户态

HdfVNodeAdapterIoctl     用户态 调用 内核态
Dispatch                 内核态 回调 用户态


```

HdfSbufObtain      hdf_core/framework/utils/src/hdf_sbuf.c
HdfSbufTypedObtainCapacity  同上

HdfSBufRaw       hdf_core/framework/utils/src/hdf_sbuf_impl_raw.c
SbufRawImplWrite 同上


HdfIoServiceBind             drivers/hdf_core/framework/core/shared/src/hdf_io_service.c 
HdfIoServiceAdapterObtain    hdf_core/framework/core/adapter/syscall/src/hdf_syscall_adapter.c
HdfSyscallAdapterDispatch     同上

HdfVNodeAdapterOpen           hdf_core/framework/core/adapter/vnode/src/hdf_vnode_adapter.c
HdfVNodeAdapterIoctl          同上
HdfVNodeAdapterServCall       同上
DeviceNodeExtDispatch         hdf_core/framework/core/common/src/hdf_device_node_ext.c



派生类的第一个成员必须是基类
通过将派生类指针转换为基类指针实现向上转型
确保基类成员在内存中的起始位置相同
两者的内存地址是相同的
