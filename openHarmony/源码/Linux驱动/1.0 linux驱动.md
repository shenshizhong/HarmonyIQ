
Linux 驱动模型
```
系统移植：
内核移植 板卡驱动移植

OpenHarmony:

字符设备驱动：led，lcd，串口
块设备驱动： 磁盘
网络设备驱动：socket 实现收发

所有设备映射成 linux 文件系统。
把设备当成文件来进行操作

怎么做驱动：
1、根据电路图，查看引脚，改设备树 dtsi （rk3568-toybrick-x0.dtsi）
   ssz_leds: ssz_leds{   //节点名 很重要
        gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
   }
2、写驱动 leds_ssz_driver.c
module_init(led_init);
module_exit(led_exit); 

3、led_init://驱动初始化函数
of_find_node_by_path("/ssz_leds")      通过设备树节点名，去获取设备节点
of_property_read_string(ssz_led.node, "status")  通过节点进去读属性  
gpiod_get_from_of_node(ssz_led.node, "gpios", 0, GPIOD_ASIS, NULL) //获取gpio引脚
cdev_init(&ssz_led.cdev, &ssz_led_fops);   //初始化led的操作
register_chrdev  或者 alloc_chrdev  注册字符设备驱动     推荐用 register_chrdev_region

led_exit：//驱动出口函数
unregister_chrdev      注销字符设备驱动

4、Makefile & Kconfig  在内核编译的时候才能加进去

drivers/leds/Makefile 中添加
obj-$(CONFIG_LED_SSZ)  += leds_ssz_driver.o

drivers/leds/Kconfig
config LEDS_SSZ                      //这个名称会对应到内核的 CONFIG_LEDS_SSZ 宏
    tristate "SSZ LED driver"
    depends on LEDS_CLASS
    help
      This option enables support for SSZ LEDs.
      
      Say Y to compile the driver into the kernel, or M to compile
      it as a module.

rk3568/arch/arm64_defconfig
CONFIG_LEDS_SSZ=y



做好之后，在设备的 dev 可以找到 led 的驱动文件   通过 cd /dev


5、 
怎么调用： 把led 当做文件去读操作，和写操作  也就是open write
1、通过 led_test.c 执行main 里面的 open，write  
2、fd = open("/dev/ssz_led", O_RDWR);
3、write(fd, databuf, sizeof(databuf))

6、
怎么通过命令控制 led_test.c：
1、通过BUILD.gn  ohos_executable("led_test"){
    sources = ["led_test.c"]
}
2、然后写到bundle.json 中，变成一个子系统。这样就会在 system/bin 中生成可执行程序

也可以编写成动态链接库，然后通过napi 去调用so











```
