


```
typedef struct LOS_DL_LIST{
    struct LOS_DL_LIST *pstPrv; //前驱节点指针
    struct LOS_DL_LIST *pstNext; //后继节点指针
} LOS_DL_LIST;

```

遍历链表
初始化链表
LITE_OS_SEC_ALW_INLINE  STATIC INLINE VOID LOS_ListInit(LOS_DL_LIST *list)
{
    list-> pstNext = list;
    list-> pstPrev = list;
}

双向链表常用于任务管理、内存管理等模块
任务控制块就包含双向链表节点：
typedef struct{
    LOS_DL_LIST penList; //用于挂载到各种等待链表
    LOS_DL_LIST threadList; //线程链表节点
    //其他成员...
}LosTaskCB;

任务控制块
无头节点设计：每个节点既是头也是尾
通过LOS_DL_LIST_ENTRY 宏可以安全地从链表节点获取包含它的结构体
原子操作保证链表操作的线程安全
轻量高效
需要更多的内存空间来存储额外的指针
更多的内存空间来存储额外的指针
template<typename T>
struct Node{
    T data;
    Node* prev;
    Node* next;
    
    Node(const T& val): data(val), prev(nullptr), next(nullptr){}
}

template <typename T>
class DoublyLinkedList{
private:
    Node<T>* head;
    Node<T>* tail;
    size_t size;

public:
    //构造函数
    DoublyLinkedList(): head(nullptr), tail(nullptr), size_t(0){}

    //析构函数
    ~DoublyLinkedList(){
        clear();
    }

    void push_front(const T& val){
        Node<T>* newNode = new Node<T>(val);
        if(empty()){
            head = tail = newNode;
        }else{
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }

        size++;
    }

    void push_back(const T& val){
        Node<T>* newNode = new Node<T>(val);
        if(empty()){
         head = tail = newNode;
        }else{
            tail -> next = newNode;
            newNode->prev = tial;
            tail = newNode;
        }
        size++;
    }   
    
    //删除头部节点
    void pop_front(){
        if(empty()) return;
        
        Node<T>* temp = head;
        head = head-next;
        if(head){
            head->prev = nullptr;    
        }else{
            tail = nullptr; //链表变为空
        }
        delete temp;
        size--;
    }

    bool empty() const{
        return size==0;
    }

    size_t getSize() const{
        return size;
    }

    void clear(){
        while(!empty()){
            pop_front();
        }
    }

    void printFoward() const{
        Node<T>* current = head;
        while(current){
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

     // 打印链表（从尾到头）
    void printBackward() const {
        Node<T>* current = tail;
        while (current) {
            std::cout << current->data << " ";
            current = current->prev;
        }
        std::cout << std::endl;
    }
}


int main(){
    DoubleLinkedList<int> dll;
    dll.push_back(10);
    dll.push_back(20);
    dll.push_front(5);
    dll.push_back(30);
        
    std::cout << "Forward: ";
    dll.printFoward();
    
    return 0;
}  




