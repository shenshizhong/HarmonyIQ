
源码框架
```
一、绝对核心
绝对核心
kernel/: 内核核心代码
arch/: 芯片架构相关代码
drivers/: 内核原生驱动（liteos/drivers 目录下）


vendor
每个芯片厂商
板级配置 驱动 内核配置 文件系统配置
kernel_configs/   内核配置选项
hals/  硬件抽象层实现，链接到//drivers 目录接口
fs/   文件系统镜像制作配置  rootfs 的内容
config.json  设备的蓝图，定义了设备的子系统，组件等能力，是编译系统选择模块的关键。

drivers
drivers/framework: HDF框架的核心实现。
drivers/adapter: 平台适配层代码， 将OS 原生API适配到HDF框架。
drivers/adapter/khdf/linux: HDF对Linux 内核的适配
你开发的驱动最终会通过vendor/厂商/产品/hals 目录链接到这里

build
build/lite/: 轻量级系统的构建配置核心
config/: 组件化配置和编译模板
toolchain/: 编译工具链配置
理解build/lite下的BUILD.gn 文件是理解鸿蒙编译系统的关键




二、重要模块

foundation
系统接触能力集合，包含了一些非常核心的子系统
foundation/ability/: 应用Ability 框架
foundation/distributedhardware/: 分布式硬件管理
foundation/graphic/: 图形UI框架
foundation/communication/: 网络通信基础能力


utils
系统基础工具和公共库
utils/native/: 提供c/c++的基础库
utils/js/: 提供JS API 的Native 实现基础


third_party
所有第三方开源库的集合。
third_party/ffmpeg/: 音频编解码库
third_party/libuv/: 异步IO库
third_party/openssl/:加密解密库
third_party/freetype/: 字体渲染库
third_party/jerryscript/: 轻量级JS引擎

applicantions
系统内置应用的源码


```

drivers 最主要的接个文件夹
```
第一优先级：
/drivers/framework  包含了驱动框架的核心实现
/core: 框架的核心管理层，包括驱动设备模型、驱动加载、初始化、服务管理等
core/host: 驱动宿主的管理，一个Host可以理解为一块物理芯片或一个功能域
core/manager: 驱动设备节点的管理
core/common: 公共模型和接口

/support: 平台支持层，为不同OS提供统一的适配接口
/include: HDF框架对上层提供的核心头文件，定义了驱动开发必须使用的标准接口和数据结构   
hdf_device_desc.h: 设备描述符，驱动入口的核心结构
hdf_device_node.h: 设备节点
hdf_driver.h: 驱动对象模型

第二优先级：
/drivers/adapter (适配层)
/adapter/khdf: Kernel HDF的缩写，是HDF框架对内核的适配
linux/:
liteos/:
adapter/uhdf: User态HDF的适配


第三优先级
/drivers/peripheral 外围驱动参考实现
提供了各种标准外设驱动的参考实现，它是你开发具体驱动的最好模板
sensor/: 传感器驱动（如加速度计）
input/: 输入设备驱动（如触摸屏，按键）
display/: 显示驱动
camera/: 摄像头驱动
usb/: USB 驱动
wlan/: WLAN 驱动


第四优先级
更底层或更具体的控制器驱动
platform/:平台相关驱动，如GPIO、I2C、SPI、UART
char/: 字符设备驱动


```
HDF 驱动模型
```
一、核心对象与概念（"演员"）
Host （驱动宿主）: 一个物理的、独立的硬件模块或者芯片，他是驱动容器，代表一个完整的驱动模块
Device : 对屋里硬件设备的抽象描述。定义设备的硬件属性，设备号，中断号，Gpio引脚、寄存器地址
Driver：驱动程序的实现本体。操作硬件设备的具体代码，初始化、读写数据、处理中断等
DeviceNode （设备节点）：Driver 和 Device 绑定后的产物。是内核对外提供服务的逻辑设备。
是驱动模型的驱动枢纽。上层应用通过DeviceNode来最终操作硬件。

二、驱动生命周期与挂念接口（"剧本"）

每个Driver都必须实现一组标准的生命周期回调函数，HDF框架会在合适的时间自动调用它们。
Bind  驱动与设备绑定时  检查设别属性是否支持
Init  驱动初始化时      初始化硬件： 配置寄存器、申请中断、申请GPIO、注册回调函数
Release 驱动退出时      释放资源：关闭中断、释放GPIO、释放内存

三、配置管理：硬件设备信息（HCS）("道具清单")
HCS 是HDF 的硬件描述语言。它将Device 的硬件信息，从C代码中解耦出来。
目的：实现驱动与设备信息的分离。同一个驱动，可以配置不同的HCS，启动适配不同的硬件板卡。

root{
device_info{
sample_host :: host{//定义一个Host，名为sample_host
sample_device :: device{ //在此Host 下定义个Device,名字sample_device
device0 :: deviceNode{//为此Device 创建一个设备节点DeviceNode
policy = 2; //服务发布策略：
priority = 100; //驱动启动优先级
preload = 0; //驱动加载策略
permission = 0664; //设备节点权限
moduleName = "sample_driver"; //关联驱动名称
serviceName = "sample_service"; //对外发布的服务名称
deviceMatchAttr = "sample_config"; //用于匹配具体的硬件属性
}

            }
        }
        
    }
    
    platform{
        sample_config{
            match_attr = "sample_config";
            led_gpio_num = 5; //自定义硬件属性：LED 连接的GPIO引脚号
        }
    }
}


四、总结
1、系统启动： HDF框架启动，解析vendor 目录下的HCF 配置文件
2、创建对象： 根据HCS 配置，创建Host、Device、DeviceNode 等对象
3、匹配与加载： 根据DeviceNode 中的moduleName，找到对应的驱动DriverEntry，并加载它。
4、执行生命周期： Bind-》Init ，完成硬件初始化
5、发布服务： 根据policy，将驱动实现的服务（serviceName）发布到内核或者用户空间
6、上层调用：应用或系统服务通过服务名称找到并调用驱动提供的接口，从而操作硬件。
7、系统退出： 调用Release 函数，安全释放所有资源。

统一的驱动开发范式，降低学习和开发成本。
驱动与设备信息分离，提高可移植性和复用性
为跨设备的硬件资源池化和贡献分布式硬件 奠定了基础。

```