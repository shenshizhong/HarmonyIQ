
```
|=：初始化
&=：只修改目标位，不影响其他位
~：让目标位，变成0，其他变成1
异或：不同为1，相同为0

设置第3位 为1             bitmap |= (1 << 3);    第3位设置为1
清除第3位（设置为0）       bitmap &= ~(1 << 3)   第3位设置为0，其他保持不变
翻转                     bitmap ^= (1 << 3);   是将第3位取反，其他保持不变
检查第3位是否为1：        if(bitmap & (1 << 3))      判断第3位

位操作是指对二进制数的bit位操作

#include <bitset>
#include <iostream>

int main(){
    std::bitset<8> bits; //8位的位图
    bits.set(2);  //设置第2位为1
    bits[5] = 1;  //设置第5位为1
    bits.reset(2); //重置第2位为0
    
    return 0;
}
```

使用位运算操作整数
```
#include <iostream>

int main(){
    unsigened int bitmap = 0; //32位位图
    
    //设置第3位
    bitmap |= (1 << 3);
    
    //检查第3位
    if(bitmap & (1 << 3)){
        std::cout << ""
    }
}

高效数据结构，适合处理大量布尔值或者标志位的场景
bitset 是固定大小的位集合容器
对于小规模的位图，整数类型和位运算符
使用位运算操作整数，对于小规模的位图，可以直接使用整数类型和位运算符

#include <iostream>
int main(){
    unsigned int bitmap = 0;  //32位位图
    //设置第3位
    bitmap |=(1 << 3);
    
    //检查第3位
    if(bitmap & (1 << 3)){
        std::cout << "Bit 3 is set" << std::endl;
    }
    
    //清除第3位
    bitmap &= ~(1 << 3);
    //切换第3位
    bitmap ^= (1 << 3);
    
    return 0;
}


0000 1101 
1*2^0 + 0*2^1 + 1*2^2 + 1*2^3 = 13
1 + 0 + 4 + 8 = 13

一个bool 类型通常占用1个字节，相当于是8个位，相对于位图，浪费空间了


对于需要动态大小的位图，可以使用vector<bool>或自己实现：
#include <vector>
#include <iostream>

class DynamicBitmap{
    std::vector<unsigned char> data;
public:
    DynamicBitmap(size_t size){
        data.resize((size + 7) / 8, 0);
    }
    
    void set(size_t pos){
        data[pos/8] |= (1 << (pos % 8));
    }
     
    bool test(size_t pos) cost{
        return data[pos/8] & (1 << (pos%8));
    }
}

int main(){
    DynamicBitmap bitmap(100);
    bitmap.set(50);
    std::cout << "Bit 50: " << bitmap.test(50) << std::endl;
    return 0;
}


```

```
VOID LOS_BitmapClrNBits(UINTPTR *bitmap, UINT32 start, UINT32 numsClear)
{
    UINTPTR *p = bitmap + BITMAP_WORD(start);
    const UINT32 size = start + numsClear;
    UINT16 bitsToClear = BITMAP_BITS_PER_WORD - (start % BITMAP_BITS_PER_WORD);
    UINTPTR maskToClear = BITMAP_FIRST_WORD_MASK(start);

    while (numsClear >= bitsToClear) {
        *p &= ~maskToClear;
        numsClear -= bitsToClear;
        bitsToClear = BITMAP_BITS_PER_WORD;
        maskToClear = OS_BITMAP_WORD_MASK;
        p++;
    }
    if (numsClear) {
        maskToClear &= BITMAP_LAST_WORD_MASK(size);
        *p &= ~maskToClear;
    }
}
```

结果导向

安装电脑，编译源码，开箱处理，移植处理。